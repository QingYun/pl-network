{"ns:m.026zd29":{"rdfs:label":["Nord Programming Language"],"ns:common.topic.description":["Nord Programming Language, commonly abbreviated NPL, was a programming language by the Norwegian minicomputer manufacturer Norsk Data. It shipped as a standard component of the operating system SINTRAN III.\\nThe language was also used to implement SINTRAN III. I.e. the core and file system of SINTRAN III was written in NPL. The NPL compiler was also written in NPL and some core applications was early on written in NPL until PLANC came and linker and other software was rewritten in PLANC.\\nThe NPL compiler was also special in that it did not produce object code as most compilers do. Instead it produced assembler code which then had to be assembled using the Norsk Data Assembler.\\nThe registers of the CPU was available in NPL as predefined variables. Thus you could write:\\nand the compiler would generate:\\nFunctions could be declared with multiple entry points:\\nFUN1 could be called to set T to 1 before falling into FUN2 or T could be set to something else and call FUN2. If T register specified which file handle to write to then either FUN1 could be called to always output to terminal or T could be specified to handle a file itself in T and call FUN2 to output to that file."],"key:en":["nord_programming_language"],"ns:common.topic.article":[{"ns:common.document.text":["NPL was a programming language by the Norwegian minicomputer manufacturer Norsk Data. It shipped as a standard component of the operating system SINTRAN III.\\nThe language was also used to implement SINTRAN III. I.e. the core and file system of SINTRAN III was written in NPL. The NPL compiler was also written in NPL and some core applications was early on written in NPL until PLANC came and linker and other software was rewritten in PLANC.\\nThe NPL compiler was also special in that it did not produce object code as most compilers do. Instead it produced assembler code which then had to be assembled using the MAC assembler.\\nThe registers of the CPU was available in NPL as predefined variables. Thus you could write:\\nand the compiler would generate:\\nFunctions could be declared with multiple entry points:\\nHere you could either call FUN1 which set T to 1 before falling into FUN2 or you could set T to something else and call FUN2. If T register specified which file handle to write to you could then either call FUN1 to always output to terminal or you could specify a file handle yourself in T and call FUN2 to output to that file."],"ns:common.document.source_uri":["<http://wp/en/8295240>"],"rdf:type":["ns:common.document"]}],"ns:type.object.name":["Nord Programming Language"],"rdf:type":["ns:computer.programming_language"],"ns:kg.object_profile.prominent_type":["ns:computer.programming_language"],"ns:common.topic.notable_for":["ns:g.12596yk7n"],"ns:common.topic.notable_types":["ns:m.01xrl_t"]}}